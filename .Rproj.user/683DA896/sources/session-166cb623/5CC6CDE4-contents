---
title: "Practicals"
author: "Mirre Dona (6156630)"
date: "2023-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r}
#use always:
library(ISLR)
library(tidyverse)
#for reading in data:
library(haven)
library(readxl)
library(readr)
library(dplyr)

library(magrittr) #to use piping %>% 
library(class) #knn()
library(MASS) #lda()
library(splines) #bs() ns()
library(cowplot) #plot_grid()
library(psych) #describeBy()
#tree based methods
library(rpart)
library(rpart.plot)
library(randomForest)
library(pROC) #ROC curve
library(caret) #bagging,  boosting, rf

#datasets
library(DAAG) #elastic
library(mice) #boys
library(MASS) #Boston & Default
```


# Practical 1
## Data types
1. Run the following code in R and inspect their data types using the class() function. Try to guess beforehand what their types will be!
```{r}
object_1 <- 1:5 #integer
object_2 <- 1L:5L #integer
object_3 <- "-123.456" #character
object_4 <- as.numeric(object_2) #numeric
object_5 <- letters[object_1] #character
object_6 <- as.factor(rep(object_5, 2)) #factor
object_7 <- c(1, 2, 3, "4", "5", "6") #character

class(object_1)
class(object_2)
class(object_3)
class(object_4)
class(object_5)
class(object_6)
class(object_7)
```

2. Convert object_7 back to a vector of numbers using the as.numeric() function
```{r}
object_7 <- as.numeric(object_7)
```

## Lists and data frames
3. Make a list called objects containing object 1 to 7 using the list() function.
```{r}
objects <- list(object_1, object_2, object_3, object_4, object_5, object_6, object_7)
```

4. Make a data frame out of object_1, object_2, and object_5 using the data.frame() function
```{r}
dat <- data.frame(Var1 = object_1, Var2 = object_2, Var3 = object_5)
dat
```
5. Useful functions for determining the size of a data frame are ncol() and nrow(). Try them out!
```{r}
ncol(dat)
```
```{r}
nrow(dat)

```
## Loading, viewing, and summarising data
6. Use the function read_csv() to import the file “googleplaystore.csv” and store it in a variable called apps.
```{r}
con <- url("https://www.gerkovink.com/slv/practicals/01_Data_Wrangling/data/googleplaystore.csv")
apps <- read_csv(con)
apps
```
7. Did any column get a variable type you did not expect?
```{r}
# Several columns such as price and number of installs were imported as 
# character data types, but they are numbers.
```

8. Use the function head() to look at the first few rows of the apps dataset
```{r}
head(apps)

```
9. Repeat steps 5, 6, and 7 but now for “data/students.xlsx” (NB: You’ll need a function from the package readxl). Also try out the function tail() and View() (with a capital V).
```{r}
students <- read_xlsx("data/students.xlsx")
head(students)
```

10. Create a summary of the three columns in the students dataset using the summary() function. What is the range of the grades achieved by the students?
```{r}
summary(students)

```

## Data transformation with dplyr verbs
### Filter
11. Look at the help pages for filter() (especially the examples) and show the students with a grade lower than 5.5
```{r}
filter(students, grade < 5.5)

```

12. Show only the students with a grade higher than 8 from programme A
```{r}
filter(students, grade > 8, programme == "A")
```
### Arrange
13. Sort the students dataset such that the students from programme A are on top of the data frame and within the programmes the highest grades come first.
```{r}
arrange(students, programme, -grade)
```

### Select
14. Show only the student_number and programme columns from the students dataset
```{r}
select(students, student_number, programme)
# or, equivalently: select(students, -grade)
```

### Mutate
```{r}
students <- mutate(students, pass = grade > 5.5)
students
```


15. Use mutate() and recode() to change the codes in the programme column of the students dataset to their names. Store the result in a variable called students_recoded
```{r}
students_recoded <- mutate(students, 
  programme = recode(programme, "A" = "Science", "B" = "Social Science")
)
```


## Data processing pipelines
```{r}
students_dataset <-
  read_xlsx("data/students.xlsx") %>% 
  mutate(prog = recode(programme, "A" = "Science", "B" = "Social Science")) %>% 
  filter(grade > 5.5) %>% 
  arrange(programme, -grade) %>% 
  select(student_number, prog, grade)
students_dataset
```

16. Create a data processing pipeline that (a) loads the apps dataset, (b) parses the number of installs as ‘Downloads’ variable using mutate and parse_number(), (c) shows only apps with more than 500 000 000 downloads, (d) orders them by rating (best on top), and (e) shows only the relevant columns (you can choose which are relevant, but select at least the Rating and Category variables). Save the result under the name popular_apps.
```{r}
popular_apps <-
  read_csv("data/googleplaystore.csv") %>% 
  mutate(Downloads = parse_number(Installs)) %>% 
  filter(Downloads > 5e8) %>% # 5e8 is the same as 5 x 10^8
  arrange(-Rating) %>% 
  select(App, Rating, Reviews, Downloads, Category) %>% 
  distinct(App, .keep_all = TRUE)
popular_apps
```
## Grouping and summarisation
students_dataset %>% 
  summarise(
    mean = mean(grade), 
    variance = var(grade), 
    min = min(grade), 
    max = max(grade)
  )

17. Show the median, minimum, and maximum for the popular apps dataset you made in the previous assignment.
```{r}
popular_apps %>% 
  summarise(
    med = median(Rating),
    min = min(Rating), 
    max = max(Rating)
  )

mad <- function(x) {
  median(abs(x - median(x)))
}
students_dataset %>% summarise(mad = mad(grade))
```
18. Add the median absolute deviation to the summaries you made before
```{r}
popular_apps %>% 
  summarise(
    med = median(Rating),
    min = min(Rating), 
    max = max(Rating),
    mad = mad(Rating)
  )

students_dataset %>% 
  group_by(prog) %>% 
  summarise(
    mean = mean(grade), 
    variance = var(grade), 
    min = min(grade), 
    max = max(grade)
  )
```
19. Create a grouped summary of the ratings per category in the popular apps dataset.

```{r}

popular_apps %>%
  group_by(Category) %>% 
  summarise(
    med = median(Rating),
    min = min(Rating), 
    max = max(Rating),
    mad = mad(Rating)
  )
```

## Final exercise
20. Create an interesting summary based on the Google play store apps dataset. An example could be “do games get higher ratings than communication apps?”
```{r}
read_csv("data/googleplaystore.csv") %>% 
  filter(Category == "GAME" | Category == "COMMUNICATION") %>% 
  select(App, Category, Rating) %>% 
  distinct(App, .keep_all = TRUE) %>% 
  group_by(Category) %>% 
  summarise(
    mean = mean(Rating, na.rm = TRUE),
    median = median(Rating, na.rm = TRUE)
  )
```

# Practical 2

## What is ggplot?
```{r}
# Inspect data ----
head(Hitters)

# Examples of the assignment ----
# histogram of the distribution of salary
hist(Hitters$Salary, xlab = "Salary in thousands of dollars")

# barplot of how many members in each league
barplot(table(Hitters$League))

# number of career home runs vs 1986 home runs
plot(x = Hitters$Hits, y = Hitters$HmRun, 
     xlab = "Hits", ylab = "Home runs")

#ggplot, build up a plot layer by layer using the + operator:
homeruns_plot <- 
  ggplot(Hitters, aes(x = Hits, y = HmRun)) +
  geom_point() +
  labs(x = "Hits", y = "Home runs")
homeruns_plot

#Example with the minimal theme.
homeruns_plot + 
  geom_density_2d() +
  labs(title = "Cool density and scatter plot of baseball data") +
  theme_minimal()
```

1. Name the aesthetics, geoms, scales, and facets of the above visualisation. Also name any statistical transformations or special coordinate systems.
```{r}
# Aesthetics: x-axis: number of hits & y-axis: amount of home runs.
# Geoms: 2d -> should have been points and counter lines.
# Scales: x-axis -> Hits (0-300) & y-axis: Home runs (0-40). both continuous.
# Facets: -
# Statistical transformation: -
# Special coordinate systems: -
```

## Aesthetics and data preparation
2. Run the code below to generate data. There will be three vectors in your environment. Put them in a data frame for entering it in a ggplot() call using either the data.frame() or the tibble() function. Give informative names and make sure the types are correct (use the as.<type>() functions). Name the result gg_students
```{r}
# Code to generate data:
set.seed(1234)
student_grade  <- rnorm(32, 7)
student_number <- round(runif(32) * 2e6 + 5e6)
programme      <- sample(c("Science", "Social Science"), 32, replace = TRUE)

# Make a dataframe called gg_students, change the names of the values and mutate the data types of number and programme.
gg_students <- data.frame(grade = student_grade, number = student_number, programme = programme) %>%
  mutate(
    number = as.character(number),
    programme = as.factor(programme)
  )

print(gg_students)  
```

3. Plot the first homeruns_plot again, but map the Hits to the y-axis and the HmRun to the x-axis instead.
```{r}
# Plot the first homeruns_plot again, but map the Hits to the y-axis and the HmRun to the x-axis instead.
homeruns_plot3 <-
  ggplot(Hitters, aes(x = HmRun, y = Hits)) +
  geom_point() +
  labs(x = "Home runs", y = "Hits")

homeruns_plot3

```

4. Recreate the same plot once more, but now also map the variable League to the colour aesthetic and the variable Salary to the size aesthetic.
```{r}
# Recreate the same plot once more, but now also map the variable League to the
#colour aesthetic and the variable Salary to the size aesthetic.
homeruns_plot4 <-
  ggplot(Hitters, aes(x = HmRun, y = Hits, colour = League, size = Salary)) +
  geom_point() +
  labs(x = "Home runs", y = "Hits")

homeruns_plot4
```

## Geoms
5. Look at the many different geoms on the reference website.
https://ggplot2.tidyverse.org/reference/#section-layer-geoms

## Visual exploratory data analysis
### Histogram

6. Use geom_histogram() to create a histogram of the grades of the students in the gg_students dataset. Play around with the binwidth argument of the geom_histogram() function.
```{r}
students_plot <-
  ggplot(gg_students, aes(x = grade)) +
  geom_histogram(binwidth = 0.3) +
  labs(x = "Grades")

students_plot 
```

### Density
7. Use geom_density() to create a density plot of the grades of the students in the gg_students dataset. Add the argument fill = "light seagreen" to geom_density().
```{r}
students_plot2 <-
  ggplot(gg_students, aes(x = grade)) +
  geom_density(fill = "light seagreen") +
  labs(x = "Grades")

students_plot2
```

8. Add rug marks to the density plot through geom_rug(). You can edit the colour and size of the rug marks using those arguments within the geom_rug() function.

```{r}
students_plot3 <-
  ggplot(gg_students, aes(x = grade)) +
  geom_density(fill = "light seagreen") +
  geom_rug(colour = "blue", size = 3) +
  labs(x = "Grades")

students_plot3
```

9. Increase the data to ink ratio by removing the y axis label, setting the theme to theme_minimal(), and removing the border of the density polygon. Also set the limits of the x-axis to go from 0 to 10 using the xlim() function, because those are the plausible values for a student grade.
```{r}
students_plot4 <-
  ggplot(gg_students, aes(x = grade)) +
  geom_density(fill = "light seagreen", color = NA) +
  geom_rug(colour = "blue", size = 3) +
  labs(x = "Grades", y = NULL) +
  theme_minimal() +
  xlim(0, 10)

students_plot4
```
### Boxplot
10. Create a boxplot of student grades per programme in the gg_students dataset you made earlier: map the programme variable to the x position and the grade to the y position. For extra visual aid, you can additionally map the programme variable to the fill aesthetic.

```{r}
students_boxplot <-
  ggplot(gg_students, aes(x = programme, y = grade), fill = programme) +
  geom_boxplot() +
  theme_minimal() +
  labs(x = "Programme", y = "Grade") +
  ggtitle("Boxplot of Student Grades per Programme")
students_boxplot
```

11. What do each of the horizontal lines in the boxplot mean? What do the vertical lines (whiskers) mean?
```{r}
# What do the vertical lines (whiskers) mean?
# They represent the programmes.

# correct answer:
# The upper whisker extends from the hinge to the largest value
# no further than 1.5 * IQR from the hinge (where IQR is the
# inter-quartile range, or distance between the first and third
# quartiles). The lower whisker extends from the hinge to the
# smallest value at most 1.5 * IQR of the hinge. Data beyond
# the end of the whiskers are called "outlying" points and are
# plotted individually.
```

### two densities
12. Comparison of distributions across categories can also be done by adding a fill aesthetic to the density plot you made earlier. Try this out. To take care of the overlap, you might want to add some transparency in the geom_density() function using the alpha argument.
```{r}
students_density <-
  ggplot(gg_students, aes(x = grade, fill = programme)) +
  geom_density(fill = "light seagreen", alpha = 0.5) +
  theme_minimal() +
  labs(y = "", fill = "Programme", colour = "Programme") +
  ggtitle("Boxplot of Student Grades")
students_density

# correct answer:
gg_students %>% 
  ggplot(aes(x = grade, fill = programme)) +
  geom_density(alpha = .5, colour = NA) +
  geom_rug(aes(colour = programme),size = 1) +
  theme_minimal() +
  labs(y = "", fill = "Programme", colour = "Programme") +
  xlim(0, 10)

```

### Barplot
13. Create a bar plot of the variable Years from the Hitters dataset.
```{r}
head(Hitters)
barplot(table(Hitters$Years))

?stat_count
table(Hitters$Years)
```

### Line plot
14. Use geom_line() to make a line plot out of the first 200 observations of the variable Volume (the number of trades made on each day) of the Smarket dataset. You will need to create a Day variable using mutate() to map to the x-position. This variable can simply be the integers from 1 to 200. Remember, you can select the first 200 rows using Smarket[1:200, ].
```{r}
Smarket[1:200,] %>% 
  mutate(Day = 1:200) %>% 
  ggplot(aes(x = Day, y = Volume)) +
  geom_line() +
  theme_minimal()
```

15. Give the line a nice colour and increase its size. Also add points of the same colour on top.
```{r}
Smarket[1:200,] %>% 
  mutate(Day = 1:200) %>% 
  ggplot(aes(x = Day, y = Volume)) +
  geom_line(colour = "lightgreen", size = 1) +
  geom_point(colour = "lightgreen", size = 2)
  theme_minimal()
```

16. Use the function which.max() to find out which of the first 200 days has the highest trade volume and use the function max() to find out how large this volume was.
```{r}
which.max(Smarket[1:200,]$Volume)
max(Smarket[1:200,]$Volume)
```

17. Use geom_label(aes(x = your_x, y = your_y, label = "Peak volume")) to add a label to this day. You can use either the values or call the functions. Place the label near the peak!
```{r}
Smarket[1:200,] %>% 
  mutate(Day = 1:200) %>% 
  ggplot(aes(x = Day, y = Volume)) +
  geom_line(colour = "lightgreen", size = 1) +
  geom_point(colour = "lightgreen", size = 2) +
  geom_label(aes(x = 170, y = 2.45, label = "Peak volume")) +
  theme_minimal()
```

## Faceting
18. Create a data frame called baseball based on the Hitters dataset. In this data frame, create a factor variable which splits players’ salary range into 3 categories. Tip: use the filter() function to remove the missing values, and then use the cut() function and assign nice labels to the categories. In addition, create a variable which indicates the proportion of career hits that was a home run.
```{r}
baseball <- Hitters %>% 
  filter(!is.na(Salary)) %>%  #filter out rows with missing salary values
  mutate(
  Salary_category = cut(.$Salary, breaks = 3, labels = c("Low", "Medium", "High")), #create factor variable for salary range into 3 categories.
  hmrun_proportion = CHmRun/CHits #make variable for proportion of career hits that were home runs.
)
```

19. Create a scatter plot where you map CWalks to the x position and the proportion you calculated in the previous exercise to the y position. Fix the y axis limits to (0, 0.4) and the x axis to (0, 1600) using ylim() and xlim(). Add nice x and y axis titles using the labs() function. Save the plot as the variable baseball_plot.

```{r}
baseball_plot <- baseball %>% 
  ggplot(aes(x = CWalks, y = hmrun_proportion)) +
  geom_point() +
  ylim(0,0.4) +
  xlim(0,1600) +
  theme_minimal() +
  labs(x = "Number of walks", y = "Proportion of home runs")

baseball_plot

```

20. Split up this plot into three parts based on the salary range variable you calculated. Use the facet_wrap() function for this; look at the examples in the help file for tips.
```{r}
?facet_wrap()
baseball_plot + facet_wrap(~Salary_category)

```

## Final exercise
21. Create an interesting data visualisation based on the Carseats data from the ISLR package.
```{r}
# answer:
Carseats %>% 
  ggplot(aes(x = Price, y = Sales, colour = ShelveLoc)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Price", y = "Sales", title = "Relationship between Shelve Location and the Price.") +
  facet_wrap(vars(ShelveLoc))


# correction, an example answer could be:
  Carseats %>% 
  mutate(Competition = Price/CompPrice,
         ShelveLoc   = fct_relevel(ShelveLoc, "Bad", "Medium", "Good")) %>% 
  ggplot(aes(x = Competition, y = Sales, colour = Age)) +
  geom_point() +
  theme_minimal() +
  scale_colour_viridis_c() + # add a custom colour scale
  facet_wrap(vars(ShelveLoc))
```



